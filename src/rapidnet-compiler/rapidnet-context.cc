/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2009 University of Pennsylvania
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "rapidnet-context.h"
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <cstdio>

#define cstr(s) (s).c_str ()
#define cname (cstr (m_classname))
#define quoted(s) ("\"" + s + "\"")

//C-style quoted
#define cquoted(s) ("\""s"\"")

#define HEADER_FILE_NAME (m_foldername + m_filename + ".h")
#define CLASS_FILE_NAME (m_foldername + m_filename + ".cc")
#define HELPER_FILE_NAME (m_foldername + m_filename + "-helper.h")

#define GENERATED_FILE_DECL \
"/* A RapidNet application. Generated by RapidNet compiler. */\n\n"

#define FMT_TUPLE_NAME_DECL \
"  static const string %s;\n"

#define FMT_TUPLE_NAME_DEFN \
"const string %s::%s = %s;\n"

#define FMT_HEADER_IFNDEF_DECL(name) \
"#ifndef " + AllCaps(name) + "_H\n\
#define " + AllCaps(name) + "_H\n\n"

#define FMT_HEADER_INCLUDE_LIST \
"#include <string>\n\
#include <iostream>\n\
#include \"ns3/ptr.h\"\n\
#include \"ns3/event-id.h\"\n\
#include \"ns3/ipv4-address.h\"\n\
#include \"ns3/rapidnet-header.h\"\n\
#include \"ns3/relation-base.h\"\n\
#include \"ns3/database.h\"\n\
#include \"ns3/%s.h\"\n\
#include \"ns3/aggregator.h\"\n\
#include \"ns3/aggwrap.h\"\n\n"


#define FMT_HEADER_USING_NS_LIST \
"using namespace std;\n\
using namespace ns3;\n\
%s\n"

#define FMT_HEADER_OPEN_NS(name) \
"namespace ns3 {\n\
\n\
class Socket;\n\
class Packet;\n\
\n\
namespace rapidnet {\n\
namespace " + AllSmall (name) + " {\n"

#define FMT_HEADER_CLOSE_NS(name) \
"} // namespace " + AllSmall (name)+ "\n\
} // namespace rapidnet\n\
} // namespace ns3\n\n"

#define FMT_HEADER_ENDIF_DECL(name) \
"#endif // " + AllCaps (name) + "_H\n"

#define FMT_EVENT_DECL(varname) \
("  EventId " + varname + ";\n")

#define FMT_COUNT_DECL(varname) \
("  uint32_t " + varname + ";\n")

#define FMT_COUNT_VAR_INIT_DEFN(varname) \
("  " + varname + " = 0;\n")

#define FMT_EVENT_VAR_NAME(rulename) \
("m_event_" + AllSmall (rulename))

#define FMT_COUNT_VAR_NAME(rulename) \
("m_count_" + AllSmall (rulename))

#define FMT_AGGREGATOR_DECL(varname) \
("  Ptr<Aggregator> " + varname + ";\n");

#define FMT_AGGWRAP_DECL(varname) \
("  Ptr<AggWrap> " + varname + ";\n");

#define FMT_AGGREGATOR_VAR_NAME(actionname, oper, var) \
("m_aggr_" + AllSmall (actionname) + Capitalize (AllSmall (oper)) + \
  Capitalize (var))

#define FMT_APP_CLASS_DECL_HEAD \
"\nclass %s : public %s\n\
{\n\
public:\n"

#define FMT_APP_CLASS_DECL_HEAD_COMMON \
"\n  static TypeId GetTypeId (void);\n\
\n\
  %s ();\n\
\n\
  virtual ~%s ();\n\
\n\
protected:\n\
\n\
  virtual void DoDispose (void);\n\
\n\
  virtual void StartApplication (void);\n\
\n\
  virtual void StopApplication (void);\n\
\n\
  virtual void InitDatabase (void);\n\
\n\
  virtual void DemuxRecv (Ptr<Tuple> tuple);\n\n"

#define FMT_APP_CLASS_DECL_TAIL "};\n\n"
#define FMT_RULE_METHOD_DECL "  virtual void %s (Ptr<Tuple> %s);\n\n"
#define FMT_RULE_METHOD_DECL_NO_ARGS \
"  virtual void %s ();\n\n"

#define FMT_CLASS_INCLUDE_LIST(name, filename) \
"#include \"" + filename + ".h\"\n\
#include <cstdlib>\n\
#include \"ns3/nstime.h\"\n\
#include \"ns3/simulator.h\"\n\
#include \"ns3/type-ids.h\"\n\
#include \"ns3/rapidnet-types.h\"\n\
#include \"ns3/rapidnet-utils.h\"\n\
#include \"ns3/assignor.h\"\n\
#include \"ns3/selector.h\"\n\
#include \"ns3/rapidnet-functions.h\"\n\n"

#define FMT_CLASS_USING_NS_LIST(name) \
"using namespace std;\n\
using namespace ns3;\n\
using namespace ns3::rapidnet;\n\
using namespace ns3::rapidnet::" + AllSmall (name) + ";\n\n"

#define FMT_LOG_DEFN(name) \
"\nNS_LOG_COMPONENT_DEFINE (\"" + Capitalize (name) + "\");\n\
NS_OBJECT_ENSURE_REGISTERED (" + Capitalize (name) + ");\n\n"

#define FMT_TYPEID_DEFN(name) \
"TypeId\n" + \
Capitalize (name) + "::GetTypeId (void)\n\
{\n\
  static TypeId tid = TypeId (\"ns3::rapidnet::" + AllSmall (name) + "::"+ Capitalize (name) + "\")\n\
    .SetParent<" + m_appBase + "> ()\n\
    .AddConstructor<" + Capitalize (name) + "> ()\n\
    ;\n\
  return tid;\n\
}\n\n"

#define FMT_CONST_DEFN(name) \
Capitalize (name) + "::" + Capitalize (name) + "()\n" + \
"{\n\
  NS_LOG_FUNCTION_NOARGS ();\n\
}\n\n"

#define FMT_DEST_DEFN(name) \
Capitalize (name) + "::~" + Capitalize (name) + "()\n" + \
"{\n\
  NS_LOG_FUNCTION_NOARGS ();\n\
}\n\n"

#define FMT_DISPOSE_DEFN(name) \
"void\n" + \
Capitalize (name) + "::DoDispose (void)\n\
{\n\
  NS_LOG_FUNCTION_NOARGS ();\n\n\
  " + m_appBase + "::DoDispose ();\n\
}\n\n"

#define FMT_STARTAPP_HEAD_DEFN(name) \
"void\n" + \
Capitalize (name) + "::StartApplication (void)\n\
{\n\
  NS_LOG_FUNCTION_NOARGS ();\n\n\
  " + m_appBase + "::StartApplication ();\n"

#define FMT_STARTAPP_TAIL_DEFN(name) \
"  RAPIDNET_LOG_INFO(\"" + Capitalize (name) + " Application Started\");\n"

#define FMT_PERIODIC_SCHEDULE_DEFN(delay, eventname, rulename) \
("  " + eventname + "=\n\
    Simulator::Schedule (Seconds ("+ delay +"), &" + \
  m_classname  + "::" + rulename + ", this);\n")

#define FMT_STOPAPP_HEAD_DEFN(name) \
"void\n" + \
Capitalize (name) + "::StopApplication ()\n\
{\n\
  NS_LOG_FUNCTION_NOARGS ();\n\n\
  " + m_appBase + "::StopApplication ();\n"

#define FMT_PERIODIC_CANCEL_DEFN(eventname) \
"  Simulator::Cancel(" + eventname + ");\n"

#define FMT_STOPAPP_LOG_DEFN(name) \
"  RAPIDNET_LOG_INFO(\"" + Capitalize (name) + " Application Stopped\");\n"

#define FMT_INIT_DATABASE_HEAD \
"void\n\
%s::InitDatabase ()\n\
{\n\
  //%s::InitDatabase ();\n\n"

#define FMT_AGGR_INIT_DEFN_HEAD \
"  %s = %s::New (%s,\n\
    this,\n\
    attrdeflist (\n"

#define FMT_AGGR_INIT_DEFN_TAIL \
"    %d);\n\n"

#define FMT_AGGWRAP_INIT_DEFN_HEAD \
"  %s = AggWrap::New<%s> (\n\
    attrdeflist (\n"

#define lookupAggrType(oper) \
(oper == "MIN" ? "AggrMin" : \
(oper == "MAX" ? "AggrMax" : "UnknownAggrError"))

#define lookupAggWrapType(oper) \
(oper == "MIN" ? "AggWrapMin" : \
(oper == "MAX" ? "AggWrapMax" : \
(oper == "COUNT" ? "AggWrapCount" : \
(oper == "LIST" ? "AggWrapList" : "UnknownAggrError"))))

#define FMT_ATTRTYPE_DEF \
"      attrdeftype (%s, %s)%s\n"

#define FMT_ADD_RELATION_HEAD \
"  AddRelationWithKeys (%s, attrdeflist ("

#define FMT_ATTRDEF \
"\n    attrdef (%s, %s)%s"

#define FMT_TIMEOUTDEF \
",\n    Seconds (%ld));\n\n"

#define FMT_DEMUX_RECV_HEAD \
"void\n\
%s::DemuxRecv (Ptr<Tuple> tuple)\n\
{\n\
  %s::DemuxRecv (tuple);\n\
\n"

#define FMT_DEMUX_RECV_IFBLOCK \
"  if (%s (tuple, %s))\n\
    {\n\
      %s (tuple);\n\
    }\n"

#define FMT_RULE_METHOD_HEAD \
"void\n\
%s::%s (Ptr<Tuple> %s)\n\
{\n\
  RAPIDNET_LOG_INFO (\"%s triggered\");\n\
\n"

#define FMT_RULE_METHOD_HEAD_NO_ARGS \
"void\n\
%s::%s ()\n\
{\n\
  RAPIDNET_LOG_INFO (\"%s triggered\");\n\
\n"

#define FMT_VERIFY_DEFN \
"  if(!Verify (%s, \"%s\"))\n\
    {\n\
      RAPIDNET_LOG_WARN (\"Verification failed!\\n\");\n\
      return;\n\
    }\n\n"

#define FMT_RESULT_RELATION_DECL "  Ptr<RelationBase> result;\n\n"
#define FMT_RESULT_TUPLE_DECL "  Ptr<Tuple> result;\n\n"
#define FMT_RESULT_TUPLE_DEFN "  Ptr<Tuple> result = %s;\n\n"

#define FMT_JOIN_DEFN \
"  result = GetRelation (%s)->Join (\n\
    %s,\n\
    strlist (%s),\n\
    strlist (%s));\n\n"

#define FMT_AGGWRAP_COMPUTE_DEFN \
"  result = %s->Compute (result);\n\n"

#define FMT_AGGWRAPLIST_COMPUTE_DEFN \
"  result = AggWrapList::New ()->Compute (result, %s, %s);\n\n"

#define FMT_AGGWRAPCOUNT_COMPUTE_DEFN \
"  result = AggWrapCount::New ()->Compute (result, %s);\n\n"

#define FMT_FUNCTION_DEFN(name, args, indent) \
(string (indent, ' ') + name + "::New (\n" + args + ")")

#define FMT_ASSIGN_DEFN_HEAD \
"  result->Assign (Assignor::New (%s,\n"

// Specify how many functions to end
#define FMT_END_FUNCTION(count) \
  string (count, ')') + ";\n"

// Assign functions have the lhs as the first argument
// in generated code. Therefore, different templates from
// Select or other functions.
#define FMT_ASSIGN_FUNCTION_DEFN \
"  result->Assign (Assignor::New (%s, %s::New (%s));\n"

#define FMT_ASSIGNOR_DEFN \
"  result->Assign (Assignor::New (%s,\n\
%s));\n"

#define FMT_ASSIGN_LOCAL_BROADCAST \
"  result->Assign (Assignor::New (%s,\n\
    %s));\n"

#define FMT_VAR_DEFN(var, indent) \
(string (indent, ' ') + "VarExpr::New (" + var + ")")

#define FMT_VALUE_DEFN(value, type, indent) \
(string (indent, ' ') + "ValueExpr::New (" \
  + type + "::New ("+ value + "))")

#define FMT_OPERATION_DEFN(op, lhs, rhs, indent) \
(string (indent, ' ') + "Operation::New (" + op + ",\n" + \
lhs + ",\n" + \
rhs + ")")

#define FMT_RANGE_DEFN(type, testExpr, lhs, rhs, indent) \
(string (indent, ' ') + "RangeExpr::New (" + type + ",\n" + \
testExpr + ",\n" + \
lhs + ",\n" + \
rhs + ")")

#define FMT_ASSIGN_STRING_DEFN \
"  result->Assign (StringAssignor::New (\n\
%s,\n\
%s));\n"

#define FMT_STRING_VAR_DEFN(var, indent) \
(string (indent, ' ') + "StringVar::New (" + var + ")")

#define FMT_STRING_VALUE_DEFN(value, indent) \
(string (indent, ' ') + "StringValue::New (\""+ value + "\")")

#define FMT_SELECT_DEFN \
"  result = result->Select (Selector::New (\n\
%s));\n"

#define FMT_SELECT_ATTRIBUTE_COMPARE_DEFN \
"  result = result->Select (P2AttributeCompare::New (\n\
    %s,\n\
%s,\n\
%s));\n"

#define FMT_BOOL_BINARY_EXPR_DEFN(op, lhs, rhs, indent) \
(string (indent, ' ') + "Operation::New (" + op + ",\n" + \
lhs + ",\n" + \
rhs + ")")

#define FMT_BOOL_UNARY_EXPR_DEFN(op, lhs, indent) \
(string (indent, ' ') + "Operation::New (" + op + ",\n" + \
lhs + ")")

#define FMT_PROJECT_DEFN \
"  result = result->Project (\n\
    %s,\n\
    strlist (%s),\n\
    strlist (%s));\n\n"

#define FMT_ENCRYPT_DEFN "  result = Encrypt (result, \"%s\"); \n"

#define FMT_ACTION_DEFN \
"  %s%s (result);\n"

/*
#define FMT_ACTION_NO_SELECTASSIGN_DEFN \
"  %s (result->Project (\n\
    %s,\n\
    strlist (%s)));\n"
*/

#define FMT_SEND_PERIODIC_DEFN \
"  SendLocal (tuple (%s, attrlist (\n\
    attr (%s, Ipv4Value, GetAddress ()),\n\
    attr (%s, Int32Value, %s))));\n\n"

#define FMT_COUNT_CHECK_BLOCK \
"  if (++%s < %s)\n\
    {\n\
    %s\
    %s\
    }\n"

// these are 2 strings separated by a comma
#define FMT_SCHEDULE_PERIODIC_DEFN(eventvar, period, classname, rulename) \
cstr ("  "+eventvar+" = Simulator::Schedule (Seconds("+period+"),\n"), \
cstr ("    &"+classname+"::"+rulename+", this);\n")


#define FMT_HELPER_CLASS(classname, filename) \
"#ifndef " + AllCaps (classname) + "_HELPER_H\n\
#define " + AllCaps (classname) + "_HELPER_H\n\
\n\
#include \"ns3/rapidnet-application-helper.h\"\n\
#include \"" + filename + ".h\"\n\
\n\
namespace ns3 {\n\
namespace rapidnet {\n\
namespace "+ AllSmall (classname) + " {\n\
\n\
class " + classname + ";\n\
\n\
class " + classname + "Helper: public RapidNetApplicationHelper\n\
{\n\
public:\n\
  " + classname + "Helper ()\n\
  {\n\
    m_factory.SetTypeId (" + classname + "::GetTypeId ());\n\
  }\n\
  virtual ~" + classname + "Helper ()\n\
  {\n\
  }\n\
\n\
protected:\n\
  Ptr<RapidNetApplicationBase> CreateNewApplication ()\n\
  {\n\
    return m_factory.Create<" + classname + "> ();\n\
  }\n\
};\n\
\n\
} // namespace " + AllSmall (classname) + "\n\
} // namespace rapidnet\n\
} // namespace ns3\n\
\n\
#endif // " + AllCaps (classname) + "_HELPER_H\n\
\n"


#define END_METHOD "}\n\n"

#define PERIODIC "periodic"
#define STR_WATCHSTUB "watchStub"
#define STR_INT32 "INT32"
#define STR_STRING "STR"
#define STR_IPV4ADDRESS "IPV4"
#define STR_DONTCARE "ANYTYPE"
#define ARG_SEP ", "
#define ZERO "0"
#define INFINITE "0"
#define STR_LOCAL_ADDRESS "LOCAL_ADDRESS"
#define STR_BROADCAST_ADDRESS "BROADCAST_ADDRESS"
#define STR_LOCAL "Local"
#define STR_BROADCAST "Broadcast"
#define DRAND48 "drand48 ()"

#define STR_AGGWRAP_OPER_COUNT "count"
#define STR_AGGWRAP_OPER_MIN "min"
#define STR_AGGWRAP_OPER_MAX "max"
#define STR_AGGWRAP_OPER_LIST "list"

#define QUAL(str1, str2) ("QUAL (" + str1 + ", " + str2 + ")")
#define instanceof(obj, type) (dynamic_cast<type> (obj) != NULL)

#define foreach_ecarule(it) \
  vector<EcaRule*> ecaRules = m_ectxt->GetEcaRules ();\
  for (vector<EcaRule*>::const_iterator it = ecaRules.begin ();\
    it != ecaRules.end (); ++it)

#define foreach_jointable(joinTables, it) \
for (vector<ParseFunctor*>::const_iterator it = joinTables.begin ();\
        it != joinTables.end (); it++)

#define foreach_selectAssign(selectAssign,it) \
  for (vector<ParseTerm*>::const_iterator it = selectAssign.begin ();\
    it != selectAssign.end (); it++)

#define HasSelectAssign(rule) (rule->_selectAssignTerms.size () > 0)
#define HasJoins(rule) (rule->probeTerms.size () > 0)

#define IsPeriodic(rule) (rule->GetEventName () == PERIODIC)
#define IsWatchStub(rule) (rule->ruleID.find (STR_WATCHSTUB) != string::npos)
#define GetAggregatePosition(rule) (rule->pAction->pFunctor->Aggregate ())
#define HasAggregate(rule) (GetAggregatePosition(rule) >= 0)
#define IsAggregateFunctor(func) (func->Aggregate () >= 0)
#define IsAggWrap(rule) (HasAggregate(rule) && rule->aggWrap == true)
#define AggWrapOper(rule) AllSmall ((dynamic_cast<ParseAgg*> (rule->pAction->pFunctor->Arg (\
      rule->pAction->pFunctor->Aggregate ()))->oper))
#define IsAggWrapCount(rule) \
  (IsAggWrap (rule) && AggWrapOper (rule) == STR_AGGWRAP_OPER_COUNT)
#define IsAggWrapList(rule) \
  (IsAggWrap (rule) && AggWrapOper (rule) == STR_AGGWRAP_OPER_LIST)
#define IsAggWrapMinMax(rule) \
  (IsAggWrap (rule) && (AggWrapOper (rule) == STR_AGGWRAP_OPER_MIN || \
  AggWrapOper (rule) == STR_AGGWRAP_OPER_MAX))

#define actionname(rule) rule->pAction->pFunctor->fName->name

using namespace std;

namespace ns3 {
namespace rapidnet_compiler {

NS_LOG_COMPONENT_DEFINE ("RapidNetContext");

string Capitalize (string str)
{
  str[0] = toupper (str[0]);
  return str;
}

string AllCaps (string str)
{
  for (unsigned int i=0; i<str.length (); ++i)
    {
      str[i] = toupper (str[i]);
    }
  return str;
}

string AllSmall (string str)
{
  for (unsigned int i=0; i<str.length (); ++i)
    {
      str[i] = tolower (str[i]);
    }
  return str;
}

string getCamelCasedName (string name)
{
  string newname = "";
  bool capitalize = true;
  for (string::iterator it = name.begin (); it < name.end (); ++it)
    {
      if (isalnum (*it))
       {
          if (capitalize)
            {
              newname += toupper (*it);
              capitalize = false;
            }
          else
            {
              newname += *it;
            }
        }
      else if (*it == '_' || *it == ' ' || *it == '-' || *it == '.')
        {
          capitalize = true;
        }
    }
  return newname;
}

string
GetDir (string name)
{
  int slashpos = name.find_last_of ("/\\");
  string dir = slashpos < 0 ? "./" : name.substr (0, slashpos+1);
  return dir;
}

string
GetFile (string name)
{
  //Remove path to get just the name
  int slashpos = name.find_last_of ("/\\");
  string filename = name.substr (slashpos + 1);

  //Remove file extensions if any
  int dotpos = filename.find_last_of ('.');
  if (dotpos > 0)
    {
      filename.erase (dotpos);
    }
  return filename;
}

string
PrepareClassname (string name)
{
  string filename = GetFile (name);
  return getCamelCasedName (filename);
}


string
FormatAttrName (string tupleName, int attrPos)
{
  stringstream strstr;
  string attrname;

  // Attributes are named as: <tablename>_attr<position>
  // Example: link_attr1, path_attr2 and so on
  // Using string stream to format the attribute name
  strstr << tupleName << "_attr" << attrPos;
  strstr >> attrname;

  return attrname;
}

string
LookupEventMethod (EcaRule* rule)
{
  ParseEvent::Event ev = rule->pEvent->event;
  switch (ev)
    {
      case ParseEvent::INSERT: return "IsInsertEvent";
      case ParseEvent::DELETE: return "IsDeleteEvent";
      case ParseEvent::RECV:   return "IsRecvEvent";
      case ParseEvent::REFRESH: return "IsRefreshEvent";
      default:
      NS_LOG_ERROR ("Unknown event! It should be either be insert, " <<
        "delete or receive!");
      return "UnknownEventError";
    }
}

string
LookupActionMethod (EcaRule* rule)
{
  ParseAction::Action act = rule->pAction->action;
  switch (act)
    {
      case ParseAction::REMOTE_SEND: return "Send";
      case ParseAction::LOCAL_SEND:  return "SendLocal";
      case ParseAction::ADD:         return "Insert";
      case ParseAction::DELETE:      return "Delete";
      default:
        NS_LOG_ERROR ("Unknown action! It should be either insert, delete " <<
        "remote send or local send!");
      return "UnknowActionError";
    }
}

string
LookupRapidNetTypeCode (string type)
{
  type = AllCaps (type);
  if (type == "INT32" || type == "STR" || type == "IPV4" || type == "REAL" ||
    type == "LIST" || type == "BOOL" || type == "SV" || type == "BYTE_ARRAY")
    {
      return type;
    }
  else if (type == "CID")
    {
      // 'ID' is a keyword. Parse error on using id for type!
      // The workaround is to call it cid or chord id.
      return "ID";
    }
  else
    {
      NS_LOG_ERROR ("Unknown type: " << type);
      return "UNKNOWN_TYPE";
    }
}

string
LookupRapidNetTypeCode (ValuePtr value)
{
  switch (value->GetTypeCode ())
  {
    case ParsedValue::INT32: return "INT32";
    case ParsedValue::STR: return "STR";
    case ParsedValue::IP_ADDR: return "IPV4";
    case ParsedValue::DOUBLE: return "REAL";
    case ParsedValue::LIST: return "LIST";
    case ParsedValue::ID: return "ID";
    case ParsedValue::SV: return "SV";
    case ParsedValue::BYTE_ARRAY: return "BYTE_ARRAY";
    default:
      NS_LOG_ERROR ("Unknown type: " << value->GetTypeName ());
      return "UNKNOWN_TYPE";
  }
}

string
LookupRapidNetValueClass (ValuePtr value)
{
  switch (value->GetTypeCode ())
  {
    case ParsedValue::INT32: return "Int32Value";
    case ParsedValue::STR: return "StrValue";
    case ParsedValue::IP_ADDR: return "Ipv4Value";
    case ParsedValue::DOUBLE: return "RealValue";
    case ParsedValue::LIST: return "ListValue";
    case ParsedValue::ID: return "IdValue";
    case ParsedValue::SV: return "SvValue";
    case ParsedValue::BYTE_ARRAY: return "ByteArrayValue";
    default:
      NS_LOG_ERROR ("Unknown type: " << value->GetTypeName ());
      return "UnknownValue";
  }
}

string
FormatVectorAsString (vector<string> list, bool withNewLines = false, int indent = 0)
{
  stringstream strstr;
  unsigned int i = 0;
  for (vector<string>::iterator it = list.begin (); it != list.end (); ++it)
    {
      ++i;
      strstr << *it;
      if (i < list.size ())
        {
          if (withNewLines)
            {
              strstr << ",\n";
              strstr << string (indent, ' ');
            }
          else
            {
              strstr << ", ";
            }
        }
    }
  return strstr.str ();
}

string
LookupFunction (string functionName)
{
  if (functionName == "f_append")
    {
      return "FAppend";
    }
  else if (functionName == "f_empty")
    {
      return "FEmpty";
    }
  else if (functionName == "f_concat")
    {
      return "FConcat";
    }
  else if (functionName == "f_item")
    {
      return "FItem";
    }
  else if (functionName == "f_member")
    {
      return "FMember";
    }
  else if (functionName == "f_now")
    {
      return "FNow";
    }
  else if (functionName == "f_size")
    {
      return "FSize";
    }
  else if (functionName == "f_last")
    {
      return "FLast";
    }
  else if (functionName == "f_removeLast")
    {
      return "FRemoveLast";
    }
  // Using f_timeDivide temporarily for FDiff
  else if (functionName == "f_diffTime")
    {
      return "FDiffTime";
    }
  // Using f_min temporarily for FHslsTtl
  else if (functionName == "f_hslsTtl")
    {
      return "FHslsTtl";
    }
  // generate rand number uint32_t and return as STRING type
  else if (functionName == "f_rand")
    {
      return "FRand";
    }
  else if (functionName == "f_typeOf")
    {
      return "FTypeOf";
    }
  else if (functionName == "f_sha1")
    {
      return "FSha1";
    }
  else if (functionName == "f_pEDB")
    { 
      return "FPEdb";
    }
  else if (functionName == "f_pIDB")
    { 
      return "FPIdb";
    }
  else if (functionName == "f_pRULE")
    { 
      return "FPRule";
    }
  /*
   * Summary Vector (SV) related functions
   */
  else if (functionName == "f_svcreate")
    {
      return "FSvCreate";
    }
  else if (functionName == "f_svin")
    {
      return "FSvIn";
    }
  else if (functionName == "f_svandnot")
    {
      return "FSvAndNot";
    }
  else if (functionName == "f_svappend")
    {
      return "FSvAppend";
    }
  else if (functionName == "f_svremove")
    {
      return "FSvRemove";
    }
  // no functions found, return error
  else
    {
      NS_LOG_ERROR ("Function " << functionName << " not known!");
      return "Error";
    }
}

void
RapidNetTable::ReadKeys (OlContext::TableInfo* tblInfo)
{
  vector<unsigned> keys = tblInfo->primaryKeys;
  vector<unsigned>::iterator it;
  string attrname;
  for (it = keys.begin (); it != keys.end (); it++)
    {
      AddKey (FormatAttrName (m_name, *it));
    }
  m_keyTypes = tblInfo->primaryKeyTypes;
}

long RapidNetTable::TIME_INFINITY = -1L;

void
RapidNetTable::SetTimeout (long timeout)
{
  if (timeout == OlContext::NO_EXPIRATION)
    {
      m_timeout = TIME_INFINITY;
    }
  else
    {
      m_timeout = timeout;
    }
}

RapidNetTuple::RapidNetTuple (string name, string id)
{
  m_name = name;
  m_id = id;
}

RapidNetTuple::RapidNetTuple (ParseFunctor* pfunctor, bool ignoreErrors)
{
  Parse (pfunctor, ignoreErrors);
  m_id = m_name;
}

RapidNetTuple::RapidNetTuple (ParseFunctor* pfunctor, string id, bool ignoreErrors)
{
  Parse (pfunctor, ignoreErrors);
  m_id = id;
}

void
RapidNetTuple::Parse (ParseFunctor* pfunctor, bool ignoreErrors)
{
  m_name = pfunctor->fName->name;
  for (int i = 0; i < pfunctor->Args (); i++)
    {
      ParseExpr* argi = pfunctor->Arg (i);
      if (instanceof (argi, ParseVar*))
        {
          ParseVar* var = dynamic_cast<ParseVar*> (argi);
          m_var2AttrNameMap[var->ToString ()] = quoted (FormatAttrName (m_name, i+1));
        }
      // Only the 3rd, 4th & 5th arguments of a periodic tuple is allowed to be a value!
      else if (m_name == PERIODIC && i == 2 && instanceof (argi, ParseVal*))
        {
          ParseVal* val = dynamic_cast<ParseVal*> (argi);
          m_isPeriodic = true;
          m_var2AttrNameMap[PERIODIC] = val->ToString ();
          // cout << val->v->toTypeString () << ":" << val->ToString () << endl;
          // default values
          m_var2AttrNameMap[DELAY] = ZERO;
          m_var2AttrNameMap[NUM_TIMES] = INFINITE;
          m_var2AttrNameMap[JITTER] = ZERO;
        }
      else if (m_isPeriodic && (i >= 3 && i <= 5) && instanceof (argi, ParseVal*))
        {
          ParseVal* val = dynamic_cast<ParseVal*> (argi);
          m_var2AttrNameMap[i == 3 ? NUM_TIMES : (i == 4 ? DELAY : JITTER)]
            = val->ToString ();
        }
      else
        {
          if (!ignoreErrors)
            {
              NS_LOG_ERROR ("In functor '" << m_name <<
                "': Tuple can only handle ParseVar");
            }
        }
    }
}

string
RapidNetTuple::GetPeriod ()
{
  if (!IsPeriodicTuple())
    {
      NS_LOG_ERROR ("Period of non-periodic tuple being requested.");
    }

  return m_var2AttrNameMap [PERIODIC];
}

bool
RapidNetTuple::HasTimes ()
{
  return m_isPeriodic && m_var2AttrNameMap[NUM_TIMES].compare (INFINITE) != 0;
}


string
RapidNetTuple::GetAttribute (string var)
{
  if (!HasAttribute (var))
    {
      NS_LOG_ERROR ("Variable " << var << " not found in result tuple!");
      return "VariableNotFoundError";
    }
  return m_var2AttrNameMap [var];
}

RapidNetTuple
RapidNetTuple::Join (FILE* ccFile, RapidNetTuple tuple, bool qualify)
{
  RapidNetTuple newtuple (m_name + "-join-" + tuple.GetName (), "result");
  map<string, string> tupleAttrMap = tuple.GetAttrMap ();

  // Copy the attributes into the new tuple. The join attributes will
  // be overwritten which is perfectly fine.

  for (map<string, string>::iterator it = tupleAttrMap.begin ();
    it != tupleAttrMap.end (); ++it)
    {
      newtuple.AddAttribute (it->first,
        qualify ? QUAL (AllCaps (tuple.GetName ()), it->second) : it->second);
    }

  for (map<string, string>::iterator it = m_var2AttrNameMap.begin ();
    it != m_var2AttrNameMap.end (); ++it)
    {
      newtuple.AddAttribute (it->first,
        qualify ? QUAL (AllCaps (m_name), it->second) : it->second);
    }

  // Create the 2 lists with corresponding join attributes
  vector<string> list1, list2;
  for (map<string, string>::iterator it = m_var2AttrNameMap.begin ();
    it != m_var2AttrNameMap.end (); ++it)
    {
      if (tupleAttrMap.find (it->first) != tupleAttrMap.end ())
        {
          list1.push_back (it->second);
          list2.push_back (tupleAttrMap [it->first]);
        }
    }

  // Note that the join code generated has 'tuple' as the first
  // operand.
  fprintf (ccFile, FMT_JOIN_DEFN,
    cstr (AllCaps (tuple.GetName ())),
    cstr (m_id),
    cstr (FormatVectorAsString (list2)),
    cstr (FormatVectorAsString (list1)));

  return newtuple;
}

RapidNetContext::RapidNetContext (string overlog, string baseOverlog)
{
  m_isSendlog = false;
  m_classname = PrepareClassname (overlog);
  m_filename = GetFile (overlog);
  m_foldername = GetDir (overlog);
  m_appBase = baseOverlog == DEFAULT_RN_APP_BASE ?
      baseOverlog : PrepareClassname (baseOverlog);
  m_baseFilename = baseOverlog == DEFAULT_RN_APP_BASE ?
     "rapidnet-application-base" : GetFile (baseOverlog);

  hFile = fopen (
    cstr (HEADER_FILE_NAME),
    "w");

  ccFile = fopen (
    cstr (CLASS_FILE_NAME),
    "w");

  helperFile = fopen (
    cstr (HELPER_FILE_NAME),
    "w");
  fprintf (helperFile, "%s", cstr (FMT_HELPER_CLASS (m_classname, m_filename)));
}

RapidNetContext::~RapidNetContext ()
{
}

void
RapidNetContext::CloseAll ()
{
  fflush (hFile);
  fclose (hFile);
  cout << "Generated header file " << HEADER_FILE_NAME << endl;

  fflush (ccFile);
  fclose (ccFile);
  cout << "Generated class file " << CLASS_FILE_NAME << endl;

  fflush (helperFile);
  fclose (helperFile);
  cout << "Generated helper file " << HELPER_FILE_NAME << endl;
}

void
RapidNetContext::Rewrite (Ptr<EcaContext> ectxt, Ptr<TableStore> tableStore)
{
  m_isSendlog = ectxt->IsSendlog ();
  m_ectxt = ectxt;
  PrepareAllTupleNames ();
  PrepareTables (tableStore);
}

void
RapidNetContext::PrepareAllTupleNames ()
{
  foreach_ecarule (it)
    {
      EcaRule* rule = *it;
      string rulename = Capitalize (rule->ruleID);
      string eventname = rule->GetEventName ();
      string actionname = rule->pAction->pFunctor->fName->name;
      m_allTupleNames [eventname] = eventname;
      m_allTupleNames [actionname] = actionname;

      vector<ParseFunctor*> joinTables = rule->probeTerms;
      foreach_jointable (joinTables, jt)
        {
          string functorname = (*jt)->fName->name;
          m_allTupleNames [functorname] = functorname;
        }
    }
}

void
RapidNetContext::PrepareTables (Ptr<TableStore> tableStore)
{
  map<string, OlContext::TableInfo*> tblInfos = *tableStore->GetTableInfos ();
  map<string, OlContext::TableInfo*>::iterator it;
  for (it = tblInfos.begin (); it != tblInfos.end (); ++it)
    {
      string tblName = it->first;
      RapidNetTable table = RapidNetTable (tblName);
      table.ReadKeys (it->second);
      table.SetTimeout (it->second->timeout);
      m_tables[tblName] = table;
      m_allTupleNames [tblName] = tblName;
    }
}

void
RapidNetContext::GenerateHeader ()
{
  fprintf (hFile, "%s", GENERATED_FILE_DECL);
  fprintf (hFile, "%s", cstr (FMT_HEADER_IFNDEF_DECL(m_classname)));
  fprintf (hFile, FMT_HEADER_INCLUDE_LIST, cstr (m_baseFilename));
  fprintf (hFile, FMT_HEADER_USING_NS_LIST, m_appBase == DEFAULT_RN_APP_BASE ?
    "": cstr ("using namespace ns3::rapidnet::" + AllSmall (m_appBase) + ";\n"));
  fprintf (hFile, "%s", cstr (FMT_HEADER_OPEN_NS(m_classname)));

  //Class declaration Head
  fprintf (hFile, FMT_APP_CLASS_DECL_HEAD, cname, m_appBase.c_str ());

  //Declare all tuple and table names
  for (map<string, string>::iterator tt = m_allTupleNames.begin ();
    tt != m_allTupleNames.end (); ++tt)
    {
      fprintf (hFile, FMT_TUPLE_NAME_DECL, cstr (AllCaps (tt->first)));
    }

  //Common pieces in the class declaration head
  fprintf (hFile, FMT_APP_CLASS_DECL_HEAD_COMMON, cname, cname);

  foreach_ecarule (it)
    {
      EcaRule* rule = *it;
      string rulename = Capitalize (rule->ruleID);
      if (IsWatchStub (rule))
        {
          continue;
        }
      if (IsPeriodic (rule))
        {
          //General format: periodic(@Src, E, Interval, Times=INFINITE, Delay=0)

          RapidNetTuple periodic (rule->pEvent->pFunctor, false);

          string eventVarName = FMT_EVENT_VAR_NAME (rulename);
          // Use empty event name, i.e. no arguments for periodics
          fprintf (hFile, FMT_RULE_METHOD_DECL_NO_ARGS, cstr (rulename));

          // note down the member variable for the periodic event
          m_memberVarDeclMap[eventVarName] = FMT_EVENT_DECL (eventVarName);

          if (periodic.HasTimes())
            {
              // note down the member variable for the periodic event count if
              // times is not infinity
              string countVarName = FMT_COUNT_VAR_NAME (rulename);
              m_memberVarDeclMap[countVarName] = FMT_COUNT_DECL (countVarName);

              // note down the initialization command
              m_memberVarInit << FMT_COUNT_VAR_INIT_DEFN (countVarName);
            }

          // Jitter in periodic is also referred to as SPACEOUT
          // note down the schedule command for the periodic,
          // check if jitter is to be included in delay
          // jitter is specified in seconds
          // drand48 generates a uniform random real number between 0.0 and 1.0
          // we multiply it with the jitter value
          if (periodic.GetAttribute(JITTER) != ZERO)
            {
              m_periodicSchedule << FMT_PERIODIC_SCHEDULE_DEFN (
                periodic.GetAttribute (DELAY) +
                  " + (" + DRAND48 + " * " + periodic.GetAttribute(JITTER) + ")",
                eventVarName, rulename);
            }
          else
            {
              m_periodicSchedule << FMT_PERIODIC_SCHEDULE_DEFN (
                periodic.GetAttribute (DELAY), eventVarName, rulename);
            }
          m_periodicCancel << FMT_PERIODIC_CANCEL_DEFN (eventVarName);
          continue;
        }

      // Print the rule method declaration
      fprintf (hFile, FMT_RULE_METHOD_DECL, cstr (rulename),
        cstr (rule->GetEventName ()));

      // Read aggregates, if any.
      ReadAggregateIfAny (rule);
    }

  // Print the member variable declarations
  for (map<string, string>::iterator it = m_memberVarDeclMap.begin ();
    it != m_memberVarDeclMap.end (); ++it)
    {
      fprintf (hFile, "%s", cstr (it->second));
    }

  fprintf (hFile, FMT_APP_CLASS_DECL_TAIL);
  fprintf (hFile, "%s", cstr (FMT_HEADER_CLOSE_NS(m_classname)));
  fprintf (hFile, "%s", cstr (FMT_HEADER_ENDIF_DECL(m_classname)));
}

void
RapidNetContext::ReadAggregateIfAny (EcaRule *rule)
{
  if (!HasAggregate (rule) || IsAggWrapCount (rule) || IsAggWrapList (rule))
     {
       return;
     }

   int pos = GetAggregatePosition (rule);
   ParseFunctor* functor = rule->pAction->pFunctor;
   string actionName = actionname (rule);
   ParseAgg* aggr = dynamic_cast<ParseAgg*> (functor->Arg (pos));
   string var = aggr->value->ToString ();
   if (var == "*")
     {
       var = "";
     }
   string m_aggrVarName = FMT_AGGREGATOR_VAR_NAME (
     actionName, aggr->oper,
     var
     );
   if (IsAggWrap(rule))
     {
       //cout << rule->_ruleID << " aggWrap " << AggWrapOper(rule) << endl;
       m_memberVarDeclMap [m_aggrVarName] = FMT_AGGWRAP_DECL (m_aggrVarName);
     }
   else
     {
       m_memberVarDeclMap [m_aggrVarName] = FMT_AGGREGATOR_DECL (m_aggrVarName);
     }
   m_ruleName2AggrVarMap [rule->ruleID] = m_aggrVarName;
}

void
RapidNetContext::GenerateClass ()
{
  GenerateClassDetails ();
  GenerateInitDatabase ();
  GenerateDemuxRecv ();
  GenerateAllRuleMethods ();
}

void
RapidNetContext::GenerateClassDetails ()
{
  fprintf (ccFile, "%s", GENERATED_FILE_DECL);
  fprintf (ccFile, "%s", cstr (FMT_CLASS_INCLUDE_LIST(m_classname, m_filename)));
  fprintf (ccFile, "%s", cstr (FMT_CLASS_USING_NS_LIST(m_classname)));

  //Define all tuple and table names
  for (map<string, string>::iterator tt = m_allTupleNames.begin ();
    tt != m_allTupleNames.end (); ++tt)
    {
      fprintf (ccFile, FMT_TUPLE_NAME_DEFN, cname, cstr (AllCaps (tt->first)),
        cstr (quoted (tt->first)));
    }

  fprintf (ccFile, "%s", cstr (FMT_LOG_DEFN(m_classname)));
  fprintf (ccFile, "%s", cstr (FMT_TYPEID_DEFN(m_classname)));
  fprintf (ccFile, "%s", cstr (FMT_CONST_DEFN(m_classname)));
  fprintf (ccFile, "%s", cstr (FMT_DEST_DEFN(m_classname)));
  fprintf (ccFile, "%s", cstr (FMT_DISPOSE_DEFN(m_classname)));

  fprintf (ccFile, "%s", cstr (FMT_STARTAPP_HEAD_DEFN(m_classname)));
  if (IsSendlog ())
    {
      fprintf (ccFile, "  SendlogInit ();\n");
    }
  fprintf (ccFile, "%s", cstr (m_periodicSchedule.str ()));
  fprintf (ccFile, "%s", cstr (m_memberVarInit.str ()));
  fprintf (ccFile, "%s", cstr (FMT_STARTAPP_TAIL_DEFN(m_classname)));
  fprintf (ccFile, "%s", END_METHOD);

  fprintf (ccFile, "%s", cstr (FMT_STOPAPP_HEAD_DEFN(m_classname)));
  fprintf (ccFile, "%s", cstr (m_periodicCancel.str ()));
  fprintf (ccFile, "%s", cstr (FMT_STOPAPP_LOG_DEFN (m_classname)));
  fprintf (ccFile, "%s", END_METHOD);
}

void
RapidNetContext::GenerateInitDatabase ()
{
  map<string, RapidNetTable>::iterator it;
  vector<string>::iterator jt;
  vector<string>::iterator kt;

  fprintf (ccFile, FMT_INIT_DATABASE_HEAD, cname, m_appBase.c_str ());
  for (it = m_tables.begin (); it != m_tables.end (); ++it)
    {
      // Do not call super.InitDatabase since we have all the table
      // information from the base application.
      //if (m_appBase != DEFAULT_RN_APP_BASE && it->first == DISCOVERY_LINK)
      //  {
      //    continue;
      //  }

      fprintf (ccFile, FMT_ADD_RELATION_HEAD, cstr (AllCaps (it->first)));
      vector<string> keys = it->second.GetKeys ();
      vector<string> keyTypes = it->second.GetKeyTypes ();
      unsigned int i = 0;
      for (jt = keys.begin (), kt = keyTypes.begin ();
        jt != keys.end () && kt != keyTypes.end (); ++jt, ++kt)
        {
          ++i;
          fprintf (ccFile, FMT_ATTRDEF,
            cstr (quoted (*jt)),
            cstr (LookupRapidNetTypeCode (*kt)),
            i == keys.size () ? ")" : ",");
        }
      if (it->second.IsTimeoutInfinity ())
        {
          //If timeout is infinity, don't specify any timeout. default is infinity
          fprintf (ccFile, ");\n\n");
        }
      else
        {
          fprintf (ccFile, FMT_TIMEOUTDEF, it->second.GetTimeout ());
        }
    }
  GenerateInitAggregators ();

  fprintf (ccFile, END_METHOD);
}

void
RapidNetContext::GenerateInitAggregators ()
{
  map<string, string> aggrDone;
  foreach_ecarule (it)
    {
      EcaRule* rule = *it;
      if (!HasAggregate (rule) || IsAggWrapCount (rule) || IsAggWrapList (rule))
        {
          continue;
        }

      string aggrVarName = m_ruleName2AggrVarMap [rule->ruleID];

      // It is possible that the same aggregator is listed
      // multiple rules (delete and insert for example). So
      // we should generate initialization code multiple times.
      if (aggrDone.find (aggrVarName) != aggrDone.end ())
        {
          continue;
        }

      aggrDone [aggrVarName] = aggrVarName;
      ParseFunctor* head = rule->pAction->pFunctor;
      string actionName = actionname (rule);
      int pos = GetAggregatePosition (rule);
      ParseAgg* aggr = dynamic_cast<ParseAgg*> (
          head->Arg (pos));

      if (IsAggWrap (rule))
        {
          if (IsAggWrapMinMax (rule))
            {
              fprintf (ccFile, FMT_AGGWRAP_INIT_DEFN_HEAD,
                cstr (aggrVarName),
                lookupAggWrapType (aggr->oper));
            }
          else
            {
              NS_LOG_ERROR ("Rule: " << rule->ruleID << " Unknown AggWrap operator: " <<
                AggWrapOper(rule));
            }
        }
      else
        {
          // Regular Aggregate
          fprintf (ccFile, FMT_AGGR_INIT_DEFN_HEAD,
            cstr (aggrVarName),
            lookupAggrType (aggr->oper),
            cstr (AllCaps (actionName)));
        }

      for (int i = 0; i < head->Args (); ++i)
        {
          fprintf (ccFile, FMT_ATTRTYPE_DEF,
            cstr (quoted (FormatAttrName (actionName, i+1))),
            STR_DONTCARE,
            i < head->Args () - 1 ? ",": "),");
        }
      fprintf (ccFile, FMT_AGGR_INIT_DEFN_TAIL, pos+1);
    }
}

void
RapidNetContext::GenerateDemuxRecv ()
{
  // Print Method head
  fprintf (ccFile, FMT_DEMUX_RECV_HEAD, cname, m_appBase.c_str ());

  foreach_ecarule (it)
    {
      EcaRule* rule = *it;
      string rulename = Capitalize (rule->ruleID);
      // Skip watchStub rules
      if (IsWatchStub (rule) || IsPeriodic (rule))
        {
          continue;
        }
        // Generate the if-block that matches tuple name and event type
        fprintf (ccFile, FMT_DEMUX_RECV_IFBLOCK, cstr (LookupEventMethod (rule)),
          cstr (AllCaps (rule->GetEventName ())), cstr (rulename));
    }
  fprintf (ccFile, END_METHOD);
}

void
RapidNetContext::GenerateAllRuleMethods ()
{
  foreach_ecarule (it)
    {
      EcaRule* rule = *it;
      string rulename = Capitalize (rule->ruleID);

      if (IsWatchStub (rule))
        {
          continue;
        }
      if (IsPeriodic (rule))
        {
          GeneratePeriodicMethod (rule);
          continue;
        }
      GenerateRuleMethod (rule);
    }
}

void
RapidNetContext::GenerateRuleMethod (EcaRule* rule)
{
  string rulename = Capitalize (rule->ruleID);
  string eventname = rule->GetEventName ();

  //Print method head
  fprintf (ccFile, FMT_RULE_METHOD_HEAD, cname, cstr(rulename),
    cstr (eventname), cstr (rulename));

  GenerateVerifyBlock (rule);

  // The result tuple is the event itself if no select/assigns.
  // If there are select/assigns then result gets updated.
  m_result = RapidNetTuple (rule->pEvent->pFunctor, false);

  // Declare a result relation if there joins or
  // declare a result tuple if there are no joins
  // and it is not an aggwrap rule
  if (HasJoins (rule))
    {
//      if (IsAggWrap (rule))
//        {
//          fprintf (ccFile, FMT_RESULT_TUPLE_DECL);
//        }
//      else
//        {
          fprintf (ccFile, FMT_RESULT_RELATION_DECL);
//        }
    }
  else
    {
      fprintf (ccFile, FMT_RESULT_TUPLE_DEFN, cstr (eventname));
    }

  GenerateAllJoins (rule);
  GenerateAllAssignments (rule);
  GenerateAllSelects (rule);
  GenerateAction (rule);

  fprintf (ccFile, END_METHOD);
}

void
RapidNetContext::GenerateVerifyBlock (EcaRule* rule)
{
  if((LookupEventMethod(rule).compare("IsRecvEvent")  == 0) &&
    rule->pEvent->pFunctor->m_auth)
    {
      int sayerPos = -1;
      for (uint32_t i = 0; i < rule->pEvent->pFunctor->m_args->size(); i++)
        {
          ParseVar *var = NULL;
          if ((var = dynamic_cast<ParseVar*> (
            rule->pEvent->pFunctor->m_args->at (i))) != NULL)
            {
              if((var->ToString()) == (rule->pEvent->pFunctor->m_sayer->ToString()))
                {
                  sayerPos = i + 1;
                  break;
                }
            }
         }
       string eventName = rule->GetEventName ();
       string attrName = FormatAttrName (eventName, sayerPos);
       fprintf(ccFile, FMT_VERIFY_DEFN, cstr (eventName), cstr (attrName));
    }
}

void
RapidNetContext::GenerateAllJoins (EcaRule* rule)
{
  vector<ParseFunctor*> joinTables = rule->probeTerms;
  bool isJoin = joinTables.size () > 0;

  if (!isJoin)
    {
      return;
    }

  string rulename = Capitalize (rule->ruleID);

  // Start with the event tuple as the base tuple
  RapidNetTuple baseTuple (rule->pEvent->pFunctor, false);

  int i = 0;

  // If it is AggWrap count, do all joins except the last one.
  // The last one will be done by the P2AggWrapCount->Compute
  // operation

  foreach_jointable (joinTables, it)
    {
      RapidNetTuple nextTuple;
      if (i++ == 0)
        {
          nextTuple = RapidNetTuple (*it, false);
        }
      else
        {
          nextTuple = RapidNetTuple (*it, string ("result"), false);
        }
      baseTuple = baseTuple.Join (ccFile, nextTuple, false);

    }

  m_result = baseTuple;
}

void
RapidNetContext::GenerateAllAssignments (EcaRule* rule)
{
  vector<ParseTerm*> selectAssign = rule->selectAssignTerms;
  foreach_selectAssign (selectAssign, it)
    {
      ParseAssign* assign = dynamic_cast<ParseAssign*> (*it);
      if (assign == NULL)
        {
          continue;
        }
      GenerateAssignment (assign);
      fprintf (ccFile, "\n");
    }

  //Check if Broadcast/Local addresses are used. They will be treated like
  //constant values assigned to attributes and projected later. Also add
  //them to the result tuple.
  RapidNetTuple action (rule->pAction->pFunctor, true);
  if (action.HasAttribute(STR_LOCAL))
    {
      fprintf (ccFile, FMT_ASSIGN_LOCAL_BROADCAST, cquoted (STR_LOCAL),
          STR_LOCAL_ADDRESS);
      m_result.AddAttribute(STR_LOCAL, cquoted (STR_LOCAL));
      fprintf (ccFile, "\n");
    }
  if (action.HasAttribute(STR_BROADCAST))
    {
      fprintf (ccFile, FMT_ASSIGN_LOCAL_BROADCAST, cquoted(STR_BROADCAST),
          STR_BROADCAST_ADDRESS);
      m_result.AddAttribute(STR_BROADCAST, cquoted (STR_BROADCAST));
      fprintf (ccFile, "\n");
    }
}

void
RapidNetContext::GenerateAssignment (ParseAssign* assign)
{
  string lhs = assign->var->ToString ();
  ParseExpr* rhs = assign->assign;

  string lhsAttrName = LookupOrQuote (lhs);
  fprintf (ccFile, FMT_ASSIGN_DEFN_HEAD, cstr (lhsAttrName));

  fprintf (ccFile, "%s",
    cstr (FormatExpression (rhs, 4)));

  fprintf (ccFile, "%s", cstr (FMT_END_FUNCTION (2)));

  m_result.AddAttribute (lhs, lhsAttrName);
}

string
RapidNetContext::FormatArgsAsString (ParseFunctor* func, bool aggWrap,
  bool withNewLines, int indent)
{
  vector<string> argslist;
  for (int i = 0; i < func->Args (); ++i)
    {
      ParseExpr* argi = func->Arg (i);
      if (instanceof (argi, ParseVar*))
        {
          argslist.push_back (m_result.GetAttribute (argi->ToString ()));
        }
      else if (IsAggregateFunctor (func) && instanceof (argi, ParseAgg*))
        {
          // cout << "Skipping aggregate " << func->fn->name << " pos " << argi->ToString() << endl;

          ParseAgg* aggr = dynamic_cast<ParseAgg*> (argi);

          // If count Aggwrap
          if (AllSmall (aggr->oper) == STR_AGGWRAP_OPER_COUNT)
            {
              // argslist.push_back (m_result.GetAttribute (STR_AGGWRAP_OPER_COUNT));

              stringstream sstr;
              sstr << "\"" << STR_AGGWRAP_OPER_COUNT << "\"";
              argslist.push_back (sstr.str());
            }
          else if (AllSmall (aggr->oper) == STR_AGGWRAP_OPER_LIST)
            {
              stringstream sstr;
              sstr << "\"" << STR_AGGWRAP_OPER_LIST << "\"";
              argslist.push_back (sstr.str());
            }
          else
            {
              // Just pick the name of the variable without the aggregate operator
              argslist.push_back (m_result.GetAttribute (aggr->value->ToString ()));
            }
        }
      else
        {
          NS_LOG_ERROR ("Only variables/aggregates are handled as functor arguments!");
        }
    }
  return FormatVectorAsString (argslist, withNewLines, indent);
}

string
RapidNetContext::FormatArgsAsString (ParseFunction* func, bool withNewLines, int indent)
{
  vector<string> argslist;
  for (int i = 0; i < func->Args (); ++i)
    {
      argslist.push_back (FormatExpression (func->Arg (i), indent));

    }
  if (argslist.empty())
    {
      return "";
    }
  return FormatVectorAsString (argslist, withNewLines, 0);
}

string
RapidNetContext::LookupOrQuote (string lhs)
{
  // The result may already contain the lhs variable. In that case
  // we need to lookup the corresponding attribute name. Otherwise,
  // it is a new attribute, simply quote it.
  if (m_result.HasAttribute (lhs))
    {
      return m_result.GetAttribute (lhs);
    }
  else
    {
      return quoted (lhs);
    }
}

string
GetBoolOperAsString (ParseBool::Operator op)
{
  string retval = "UnknownBoolOperatorError";
  switch (op)
  {
  case ParseBool::AND: retval = "RN_AND"; break;
  case ParseBool::OR: retval = "RN_OR"; break;
  case ParseBool::NOT: retval = "RN_NOT"; break;
  case ParseBool::EQ: retval = "RN_EQ"; break;
  case ParseBool::NEQ: retval = "RN_NEQ"; break;
  case ParseBool::LT: retval = "RN_LT"; break;
  case ParseBool::LTE: retval = "RN_LTE"; break;
  case ParseBool::GT: retval = "RN_GT"; break;
  case ParseBool::GTE: retval = "RN_GTE"; break;
  case ParseBool::RANGE: retval = "RN_IN_RANGE"; break;
  default:
    NS_LOG_ERROR ("Unknown operator");
  }
  return retval;
}

string
RapidNetContext::FormatExpression (ParseExpr* expr, int indent)
{
  if (instanceof (expr, ParseVar*))
    {
      return FMT_VAR_DEFN (
        LookupOrQuote (expr->ToString ()), indent);
    }
  else if (instanceof (expr, ParseVal*))
    {
      ParseVal* value = dynamic_cast<ParseVal*> (expr);
      string str = expr->ToString ();
      if (value->value->GetTypeCode () == ParsedValue::ID)
        {
          // Remove leading 0x and trailing I and quote it
          // and set the base as 16
          uint32_t len = str.length ();
          str = str.substr (2, len - 3);
          str = "\"" + str + "\", 16";
        }
      else if (value->value->GetTypeCode () == ParsedValue::STR)
        {
          str = "\"" + str + "\"";
        }
      return FMT_VALUE_DEFN (str, LookupRapidNetValueClass (
        value->value), indent);
    }
  else if (instanceof (expr, ParseMath*))
    {
      ParseMath* math = dynamic_cast<ParseMath*> (expr);
      string op;
      switch (math->oper)
        {
          case ParseMath::PLUS: op = "RN_PLUS"; break;
          case ParseMath::MINUS: op = "RN_MINUS"; break;
          case ParseMath::TIMES: op = "RN_MULT"; break;
          case ParseMath::DIVIDE: op = "RN_DIV"; break;
          case ParseMath::LSHIFT: op = "RN_LSHIFT"; break;
          case ParseMath::RSHIFT: op = "RN_RSHIFT"; break;
          default: op = "UnknownOperatorError";
          NS_LOG_ERROR ("Unknown Operator!");
        }

      return FMT_OPERATION_DEFN (op,
        FormatExpression (math->lhs, indent + 2),
        FormatExpression (math->rhs, indent + 2), indent);
    }
  else if (instanceof (expr, ParseFunction*))
    {
      ParseFunction* function = dynamic_cast<ParseFunction*> (expr);
      return FMT_FUNCTION_DEFN (
        LookupFunction (function->Name ()),
        FormatArgsAsString (function, true, indent + 2), indent);
    }
  else if (instanceof (expr, ParseBool*))
    {
      ParseBool* boolExpr = dynamic_cast<ParseBool*> (expr);
      string type = GetBoolOperAsString (boolExpr->oper);

      if (boolExpr->oper == ParseBool::NOT)
        {
          return FMT_BOOL_UNARY_EXPR_DEFN (type,
            FormatExpression (boolExpr->lhs, indent + 2),
            indent);
        }
      else if (boolExpr->oper == ParseBool::RANGE)
        {
          if (!instanceof (boolExpr->rhs, ParseRange*))
            {
              NS_LOG_ERROR ("RHS of boolean range operator "
                "should be a range expression");
              return "BadRangeExpression";
            }
          ParseRange* range = dynamic_cast<ParseRange*> (boolExpr->rhs);
          string type;
          switch (range->type)
          {
            case ParseRange::RANGECC: type = "RangeExpr::RANGECC"; break;
            case ParseRange::RANGEOC: type = "RangeExpr::RANGEOC"; break;
            case ParseRange::RANGECO: type = "RangeExpr::RANGECO"; break;
            case ParseRange::RANGEOO: type = "RangeExpr::RANGEOO"; break;
          }
          return FMT_RANGE_DEFN (type,
            FormatExpression (boolExpr->lhs, indent + 2),
            FormatExpression (range->lhs, indent + 2),
            FormatExpression (range->rhs, indent + 2),
            indent);
        }
      else
        {
          return FMT_BOOL_BINARY_EXPR_DEFN (type,
            FormatExpression (boolExpr->lhs, indent + 2),
            FormatExpression (boolExpr->rhs, indent + 2),
            indent);
        }
    }
  else
    {
      NS_LOG_ERROR ("Unknown Expression!");
      return "UnknownExprError";
    }
}

void
RapidNetContext::GenerateAllSelects (EcaRule* rule)
{
  vector<ParseTerm*> selectAssign = rule->selectAssignTerms;
  foreach_selectAssign (selectAssign, it)
    {
      ParseSelect* select = dynamic_cast<ParseSelect*> (*it);
      if (select == NULL)
        {
          continue;
        }
      GenerateSelect (select);
      fprintf (ccFile, "\n");
    }
}

void
RapidNetContext::GenerateSelect (ParseSelect* select)
{
  ParseBool* boolExpr = select->select;

  fprintf (ccFile, FMT_SELECT_DEFN,
    cstr (FormatExpression ((ParseExpr*)boolExpr, 4)));
}

void
RapidNetContext::GenerateAction (EcaRule* rule)
{
  ParseAction::Action actionCode = rule->pAction->action;
  ParseFunctor* action = rule->pAction->pFunctor;

  //cout << rule->_ruleID << "::AggWrap: "  << rule->_aggWrap;

  string actionMethod = LookupActionMethod (rule);

  // The list of attribute names in the result tuple.
  string resultAttrs = FormatArgsAsString (action, IsAggWrap (rule), true, 6);

  // The list of attribute names in the projected tuple.
  string projectedTupleName = rule->pAction->pFunctor->fName->name;
  vector<string> projectedAttrs;
  for (int i = 0; i < action->Args (); ++i)
    {
      if (instanceof (action->Arg (i), ParseVar*) ||
        (instanceof (action->Arg (i), ParseAgg*) /*&&
        IsAggWrapCount(rule)*/))
        // Add additional attribute for count
        {
          projectedAttrs.push_back (
            quoted (FormatAttrName (projectedTupleName, i+1)));
        }
    }

  // If it is remote send then set the P2DEST attribute.
  if (actionCode == ParseAction::REMOTE_SEND)
    {
      // Remove the @ sign.
      string locspec = action->GetLocSpec ().erase (0, 1);
      string locAttr = Lookup (locspec);
      resultAttrs = resultAttrs + ",\n      " + locAttr;
      projectedAttrs.push_back ("RN_DEST");
    }

  if (HasAggregate (rule))
    {
      if (IsAggWrap (rule))
        {
          if (IsAggWrapMinMax (rule))
            {
              string oper = AllSmall (rule->pAction->pFunctor->AggregateOperator());

              fprintf (ccFile, FMT_PROJECT_DEFN,
                       cstr (AllCaps (projectedTupleName)),
                       cstr (resultAttrs),
                       cstr (FormatVectorAsString (projectedAttrs, true, 6)));
              
              fprintf (ccFile, FMT_AGGWRAP_COMPUTE_DEFN,
                       cstr (m_ruleName2AggrVarMap[rule->ruleID]));
              
              fprintf (ccFile, FMT_ACTION_DEFN, "",
                       cstr (actionMethod));
            }
          else if (IsAggWrapList(rule))
            {
              ParseExpr* arg = action->Arg (action->Args()-1);
              ParseAgg* aggr = dynamic_cast<ParseAgg*> (arg);

              // Apply the P2AggWrapList->Compute operation              
              fprintf (ccFile, FMT_AGGWRAPLIST_COMPUTE_DEFN, 
                       cstr (rule->pEvent->pFunctor->fName->name),
                       cstr (m_result.GetAttribute (aggr->value->ToString ())));

              fprintf (ccFile, FMT_PROJECT_DEFN,
                       cstr (AllCaps (projectedTupleName)),
                       cstr (resultAttrs),
                       cstr (FormatVectorAsString (projectedAttrs, true, 6)));
                
              fprintf (ccFile, FMT_ACTION_DEFN, "",
                       cstr (actionMethod));
            }
          else if (IsAggWrapCount(rule))
            {
              // Apply the P2AggWrapCount->Compute operation
              fprintf (ccFile, FMT_AGGWRAPCOUNT_COMPUTE_DEFN, cstr(rule->pEvent->pFunctor->fName->name));
  
              fprintf (ccFile, FMT_PROJECT_DEFN,
                       cstr (AllCaps (projectedTupleName)),
                       cstr (resultAttrs),
                       cstr (FormatVectorAsString (projectedAttrs, true, 6)));
                          
              fprintf (ccFile, FMT_ACTION_DEFN, "",
                       cstr (actionMethod));
            }
          else
            {
              NS_LOG_ERROR ("Rule: " << rule->ruleID <<
                            " Unknown AggWrap operator: " << AggWrapOper(rule));
            }
        }
      else // regular aggregate
        {
          fprintf (ccFile, FMT_PROJECT_DEFN,
                   cstr (AllCaps (projectedTupleName)),
                   cstr (resultAttrs),
                   cstr (FormatVectorAsString (projectedAttrs, true, 6)));

          fprintf (ccFile, FMT_ACTION_DEFN,
                   cstr (m_ruleName2AggrVarMap[rule->ruleID]+ "->"),
                   cstr (actionMethod));
        }
    }
  else
    {
      fprintf (ccFile, FMT_PROJECT_DEFN,
               cstr (AllCaps (projectedTupleName)),
               cstr (resultAttrs),
               cstr (FormatVectorAsString (projectedAttrs, true, 6)));

      GenerateSignEncryptBlock (rule, actionMethod);
      fprintf (ccFile, FMT_ACTION_DEFN, "", cstr (actionMethod));
    }
}

void
RapidNetContext::GenerateSignEncryptBlock (EcaRule* rule, string actionMethod)
{
  if (actionMethod.compare("Send") != 0)
    {
      return;
    }

  string projectedTupleName = rule->pAction->pFunctor->fName->name;

  if (rule->pAction->pFunctor->m_auth)
    {
      fprintf (ccFile, FMT_ACTION_DEFN, "","Sign");
    }

  if (rule->pAction->pFunctor->m_encrypt)
    {
      int destPos = -1;
      for(uint32_t i = 0; i < rule->pAction->pFunctor->m_args->size(); i++)
        {
          ParseVar *var = NULL;
          if ((var = dynamic_cast<ParseVar*> (
              rule->pAction->pFunctor->m_args->at (i))) != NULL)
            {
              //find the position of location specifier
              if(var->LocSpec ())
                {
                  destPos = i + 1;
                  break;
                }
            }
        }

      string attrName = FormatAttrName (projectedTupleName, destPos);
      fprintf (ccFile, FMT_ENCRYPT_DEFN, cstr(attrName));
    }
}

string
RapidNetContext::Lookup (string lhs)
{
  // The result may already contain the lhs variable. In that case
  // we need to lookup the corresponding attribute name. Otherwise,
  // it is a new attribute, simply quote it.
  if (m_result.HasAttribute (lhs))
    {
      return m_result.GetAttribute (lhs);
    }
  else
    {
      NS_LOG_ERROR ("The variable " << lhs <<
        " was not found in the result!");
      return "VariableNotFoundInResultError";
    }
}

void
RapidNetContext::GeneratePeriodicMethod (EcaRule* rule)
{
  //General format: periodic(@Src, E, Interval, Times=INFINITE, Delay=0)

  string rulename = Capitalize (rule->ruleID);
  string eventname = rule->GetEventName ();

  //Print method head
  fprintf (ccFile, FMT_RULE_METHOD_HEAD_NO_ARGS, cname, cstr(rulename),
    cstr (rulename));

  // The result tuple is the event itself if no select/assigns.
  // If there are select/assigns then result gets updated.
  RapidNetTuple periodic (rule->pEvent->pFunctor, false);

  string actionName = actionname (rule);

  fprintf (ccFile, FMT_SEND_PERIODIC_DEFN,
    // The action name is the tuple name
    cstr (AllCaps (actionName)),
    // The variable for the current address is the first argument
    cstr (quoted (FormatAttrName (actionName, 1))),
    // The variable for the event is the second argument
    cstr (quoted (FormatAttrName (actionName, 2))),
    // Send a randomly generated value for eventId
    "rand ()");

  string eventvar = FMT_EVENT_VAR_NAME (rulename);

  if (periodic.HasTimes())
    {
      string countvar = FMT_COUNT_VAR_NAME (rulename);
      fprintf (ccFile, FMT_COUNT_CHECK_BLOCK, cstr (countvar),
        cstr (periodic.GetTimes()),
        FMT_SCHEDULE_PERIODIC_DEFN(
          eventvar,
          periodic.GetPeriod (),
          m_classname,
          rulename));
    }
  else
    {
      fprintf(ccFile, "%s%s", FMT_SCHEDULE_PERIODIC_DEFN(
        eventvar,
        periodic.GetPeriod (),
        m_classname,
        rulename));
    }

  fprintf (ccFile, END_METHOD);
}

} // namespace ns3
} // namespace rapidnet_compiler
